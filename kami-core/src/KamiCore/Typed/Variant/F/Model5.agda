
{-# OPTIONS --allow-unsolved-metas --rewriting #-}

module KamiCore.Typed.Variant.F.Model5 where

open import Agora.Conventions hiding (k ; _‚à£_ ; _‚äî_ ; ls)
open import Agora.Data.Product.Definition
open import Agora.Order.Preorder
open import Agora.Order.Lattice
open import KamiTheory.Order.StrictOrder.Base
open import KamiTheory.Data.UniqueSortedList.Definition
open import KamiTheory.Data.List.Definition



record isProcessSet ùëó (L : Preorder ùëñ) : ùí∞ (ùëñ ÔΩ§ ùëó ‚Å∫) where
  field Proc : StrictOrder ùëó
  field all : ‚ü® L ‚ü©
  field split : ‚ü® L ‚ü© -> ùí´·∂†‚Å±‚Åø Proc
  field re : ‚ü® Proc ‚ü© -> ‚ü® L ‚ü©

  instance
    hasDecidableEquality:Proc : hasDecidableEquality ‚ü® Proc ‚ü©
    hasDecidableEquality:Proc = hasDecidableEquality:byStrictOrder

open isProcessSet public using (Proc)
open isProcessSet {{...}} public using (split ; re ; all ; hasDecidableEquality:Proc)





-- module IR {Loc : Preorder ùëñ} {{_ : hasFiniteMeets Loc}} (split : ‚ü® Loc ‚ü© -> ùí´·∂†‚Å±‚Åø (Proc L)) where
module IR {Loc : Preorder ùëñ} {{L : isProcessSet ùëó Loc}} where


  private variable
    k l : ‚ü® Loc ‚ü©
    ks ls : ùí´·∂†‚Å±‚Åø (Proc L)
    p q : ‚ü® Proc L ‚ü©


  data ‚ñ≤Type : ùí∞ ùëñ
  data ‚óØType : ‚ü® Loc ‚ü© -> ùí∞ ùëñ
  data Com : ùí∞ ùëñ


  data ‚ñ≤Type where
    -- the boxing operator:
    -- actually the list of locations should be the
    -- partition of `l`.
    ‚óª : ‚óØType l -> ‚ñ≤Type
    NN : ‚ñ≤Type
    Unit : ‚ñ≤Type
    Either : ‚ñ≤Type -> ‚ñ≤Type -> ‚ñ≤Type
    -- _[_]‚áí_ : ‚ñ≤Type -> 

  pattern BB = Either Unit Unit

  -- infix 40 ‚óª_‚à£_

  data ‚óØType where
    _Ôº†_ : ‚ñ≤Type -> (l : ‚ü® Loc ‚ü©) -> ‚óØType l
    _‚áí_ : ‚óØType l -> ‚óØType l -> ‚óØType l

  infix 30 _Ôº†_
  infix 45 _‚áí_

  data ‚óØCtx : ùí∞ ùëñ where
    Œµ : ‚óØCtx
    _,_¬©_ : ‚óØCtx -> ‚óØType l -> Com -> ‚óØCtx

  infixl 30 _,_¬©_


  data ‚ñ≤Ctx : ùí∞ ùëñ where
    Œµ : ‚ñ≤Ctx
    _,_¬©_ : ‚ñ≤Ctx -> ‚ñ≤Type -> Com -> ‚ñ≤Ctx

  private variable
    Œì Œî : ‚óØCtx
    X Y Z : ‚óØType l
    Œû : ‚ñ≤Ctx
    A B C D : ‚ñ≤Type



  -- data _‚ä¢‚óØ_ : ‚óØCtx -> ‚óØType l -> ùí∞ ùëñ
  data _‚ä¢‚óØ-Var_¬©_ : ‚óØCtx -> ‚óØType l -> Com -> ùí∞ ùëñ
  -- data _‚ä¢_//_ : ‚óØCtx -> ‚ñ≤Type -> ‚ü® Loc ‚ü© -> ùí∞ ùëñ
  data _‚áõ_‚à£_ : ‚óØCtx -> ‚óØCtx -> ùí´·∂†‚Å±‚Åø (Proc L) -> ùí∞ (ùëñ ÔΩ§ ùëó)

  data Com where
    -- var : Œì ‚ä¢‚óØ-Var X -> Com
    com : ‚óØType l -> ‚ü® Loc ‚ü© -> Com
    _‚à•_ : (Œ¥‚ÇÄ Œ¥‚ÇÅ : Com) -> Com
    _‚â´_ : (Œ¥‚ÇÄ Œ¥‚ÇÅ : Com) -> Com
    _‚äπ_ : (Œ¥‚ÇÄ Œ¥‚ÇÅ : Com) -> Com
    [] : Com
    -- app : Œì , X ‚ä¢‚óØ-Com -> 

  -- _[_]-Com : suc Com -> Com -> Com
  -- _[_]-Com = {!!}

  private variable
    Œ¥ Œ¥‚ÇÄ Œ¥‚ÇÅ : Com

  data isLocal (l : ‚ü® Loc ‚ü©) : ‚óØCtx -> ùí∞ ùëñ where
    Œµ : isLocal l Œµ
    step : isLocal l Œì -> isLocal l (Œì , A Ôº† l ¬© Œ¥)

  -- _‚ä¢_ : ‚óØCtx -> ‚óØType l -> ùí∞ ùëñ
  -- _‚ä¢_ Œì A = Œì ‚ä¢[ ùüò ] A

  data _‚ä¢‚óØ-Var_¬©_ where
    zero : Œì , X ¬© Œ¥ ‚ä¢‚óØ-Var X ¬© Œ¥
    suc : Œì ‚ä¢‚óØ-Var X ¬© Œ¥‚ÇÄ -> Œì , Y ¬© Œ¥‚ÇÅ  ‚ä¢‚óØ-Var X ¬© Œ¥‚ÇÄ

{-
  data _‚ä¢‚óØ_ where
    broadcast : Œì ‚ä¢‚óØ ‚óª X ‚à£ ks Ôº† l -> Œì ‚ä¢‚óØ X
    lam : Œì , X ‚ä¢‚óØ Y -> Œì ‚ä¢‚óØ X ‚áí Y
    app : Œì ‚ä¢‚óØ X ‚áí Y -> Œì ‚ä¢‚óØ X -> Œì ‚ä¢‚óØ Y
    -- seq : Œì ‚ä¢ X -> Œì , X ‚ä¢ Y -> Œì ‚ä¢ Y

-}

  data _‚à£_‚Ü¶_ : ‚óØType l -> ‚ü® Proc L ‚ü© -> ‚ñ≤Type -> ùí∞ (ùëñ ÔΩ§ ùëó) where
    proj-Ôº† : ‚àÄ{k} -> l ‚â§ re k -> A Ôº† l ‚à£ k ‚Ü¶ A
    proj-Ôº†-‚â† : ‚àÄ{k} -> (¬¨ l ‚â§ re k) -> A Ôº† l ‚à£ k ‚Ü¶ Unit


  data _‚ä¢‚óØ_//_¬©_ : (Œì : ‚óØCtx) -> ‚ñ≤Type -> ‚ü® Proc L ‚ü© -> Com -> ùí∞ (ùëñ ÔΩ§ ùëó)



  _‚ä¢‚óª_‚à£_//_ : ‚óØCtx -> ‚óØType l -> ùí´·∂†‚Å±‚Åø (Proc L) -> ‚ü® Proc L ‚ü© -> ùí∞ _
  _‚ä¢‚óª_‚à£_//_ Œì X ks q = ‚àÄ p -> p ‚àà ‚ü® ks ‚ü© -> ‚àÄ A -> X ‚à£ p ‚Ü¶ A -> Œì ‚ä¢‚óØ A // q ¬© []


{-
  data _‚ä¢‚óª_‚à£_//_ : ‚óØCtx -> ‚óØType l -> ùí´·∂†‚Å±‚Åø (Proc L) -> ‚ü® Loc ‚ü© -> ùí∞ ùëñ where
    [] : Œì ‚ä¢‚óª X ‚à£ [] // l
    _,_by_ : Œì ‚ä¢‚óª X ‚à£ ks // l -> X ‚à£ p ‚Ü¶ A -> Œì ‚ä¢‚óØ A // l ¬© [] -> Œì ‚ä¢‚óª X ‚à£ (k ‚à∑ ks) // l
    -}



  _‚ä¢‚óØ_‚à£_¬©_ : ‚óØCtx -> ‚óØType l -> ùí´·∂†‚Å±‚Åø (Proc L) -> Com -> ùí∞ _
  _‚ä¢‚óØ_‚à£_¬©_ Œì X ps Œ¥ = ‚àÄ p -> p ‚àà ‚ü® ps ‚ü© -> ‚àÄ A -> X ‚à£ p ‚Ü¶ A -> Œì ‚ä¢‚óØ A // p ¬© []

{-
  data _‚ä¢‚óØ_‚à£_¬©_ : ‚óØCtx -> ‚óØType l -> ùí´·∂†‚Å±‚Åø (Proc L) -> Com -> ùí∞ ùëñ where
    [] : Œì ‚ä¢‚óØ X ‚à£ [] ¬© Œ¥
    _,_by_ : Œì ‚ä¢‚óØ X ‚à£ ks ¬© Œ¥ -> X ‚à£ p ‚Ü¶ A -> Œì ‚ä¢‚óØ A // k ¬© Œ¥ -> Œì ‚ä¢‚óØ X ‚à£ (k ‚à∑ ks) ¬© Œ¥
    -}

  data _‚ä¢‚óØ_//_¬©_ where

    var : (i : Œì ‚ä¢‚óØ-Var X ¬© Œ¥) -> X ‚à£ p ‚Ü¶ A -> Œì ‚ä¢‚óØ A // p ¬© Œ¥

    tt : Œì ‚ä¢‚óØ Unit // p ¬© []

    -- recv : X ‚à£ l ‚Ü¶ A -> Œì ‚ä¢‚óØ A // l ¬© com X k
    recv : Œì , X ¬© [] ‚ä¢‚óØ A // p ¬© Œ¥
         -> Œì ‚ä¢‚óØ A // p ¬© (com X k ‚â´ Œ¥)

    send : Œì ‚ä¢‚óØ ‚óª X // p ¬© []
         -> Œì , X ¬© [] ‚ä¢‚óØ A // p ¬© Œ¥
         -> Œì ‚ä¢‚óØ A // p ¬© (com X (re p) ‚â´ Œ¥)

    -- seq : Œì ‚ä¢‚óØ A // k ¬© Œ¥‚ÇÄ
    --     -> Œì , A Ôº† k ¬© [] ‚ä¢‚óØ B // k ¬© Œ¥‚ÇÅ
    --     -> Œì ‚ä¢‚óØ B // k ¬© (Œ¥‚ÇÄ ‚â´ Œ¥‚ÇÅ)

    box : ‚àÄ{X : ‚óØType k} -> Œì ‚ä¢‚óª X ‚à£ split {{L}} k // p -> Œì ‚ä¢‚óØ ‚óª X // p ¬© []

    rec-Either : Œì ‚ä¢‚óØ Either A B // p ¬© []
               -> Œì , A Ôº† re p ¬© [] ‚ä¢‚óØ C // p ¬© Œ¥‚ÇÄ
               -> Œì , B Ôº† re p ¬© [] ‚ä¢‚óØ C // p ¬© Œ¥‚ÇÅ
               -> Œì ‚ä¢‚óØ C // p ¬© (Œ¥‚ÇÄ ‚äπ Œ¥‚ÇÅ)

    left : Œì ‚ä¢‚óØ A // p ¬© Œ¥
         -> Œì ‚ä¢‚óØ Either A B // p ¬© Œ¥

    right : Œì ‚ä¢‚óØ B // p ¬© Œ¥
         -> Œì ‚ä¢‚óØ Either A B // p ¬© Œ¥

    -- lam : Œì , A ‚ä¢‚óØ B // k ¬© Œ¥ -> Œì ‚ä¢‚óØ A [ ]‚áí


  -- data _‚ä¢‚óØ_/_¬©_ : (Œì : ‚óØCtx) -> ‚óØType l -> ùí´·∂†‚Å±‚Åø (Proc L) -> Com -> ùí∞ ùëñ where
  --   [] : Œì ‚ä¢‚óØ X / ks ¬© Œ¥
  --   _,_by_ : Œì ‚ä¢‚óØ X / ks ¬© Œ¥ -> X ‚à£ p ‚Ü¶ A -> Œì ‚ä¢‚óØ A // k ¬© Œ¥ -> Œì ‚ä¢‚óØ X / (k ‚à∑ ks) ¬© Œ¥

  infixl 23 _,_by_



  -- data _‚ä¢_//_ where
    -- rec-Either : Œì ‚ä¢ Either A B // l
    --            -> Œì , A Ôº† l ‚ä¢ C // l
    --            -> Œì , B Ôº† l ‚ä¢ C // l
    --            -> Œì ‚ä¢ C // l

    -- box : Œì ‚ä¢‚óª X ‚à£ ks // l -> Œì ‚ä¢ ‚óª X ‚à£ ks // l

  -- data _‚ä¢‚ñ≤_¬©_ : (Œì : ‚ñ≤Ctx) -> ‚ñ≤Type -> Œì ‚ä¢‚óØ-> ùí∞ ùëñ where

  data _‚ä¢‚ñ≤-Var_¬©_ : ‚ñ≤Ctx -> ‚ñ≤Type -> Com -> ùí∞ ùëñ where
    zero : Œû , A ¬© Œ¥ ‚ä¢‚ñ≤-Var A ¬© Œ¥
    suc : Œû ‚ä¢‚ñ≤-Var A ¬© Œ¥ -> Œû , B ¬© Œ¥‚ÇÅ ‚ä¢‚ñ≤-Var A ¬© Œ¥

  data _‚áõ_‚à£_ where
    Œµ : Œì ‚áõ Œµ ‚à£ ks
    _,_ : Œì ‚áõ Œî ‚à£ ks -> Œì ‚ä¢‚óØ X ‚à£ ks ¬© Œ¥ -> Œì ‚áõ Œî , X ¬© Œ¥ ‚à£ ks

{-
  embed-Term : Œì ‚ä¢‚óØ X ‚à£ (l ‚à∑ []) ¬© Œ¥ -> Œì ‚ä¢‚óØ X ‚à£ split ‚ä§ ¬© Œ¥
  embed-Term = {!!}

  embed-‚áõ : Œì ‚áõ Œî ‚à£ (l ‚à∑ []) -> Œì ‚áõ Œî ‚à£ split ‚ä§
  embed-‚áõ = {!!}

-}

  ----------------------------------------------------------
  -- Constructing the categories
  --
  -- The local categories.
  -- Note that the Loc here is the location where the local
  -- type should be located (ergo we don't have ‚à®, but have
  -- an ‚àß operation)
  ‚ñ≤Obj : ‚ü® Proc L ‚ü© -> ùí∞ ùëñ
  ‚ñ≤Obj l = ‚àë isLocal (re l)

  ‚ñ≤Hom : ‚àÄ l -> ‚ñ≤Obj l -> ‚ñ≤Obj l -> ùí∞ _
  ‚ñ≤Hom l (Œì , ŒìP) (Œî , ŒîP) = Œì ‚áõ Œî ‚à£ ‚¶ó l ‚¶ò


  -- The global category.
  -- Note that the loc here is the range of processes that
  -- participate in the choreography, thus only should contain
  -- ‚à® operations).
  ‚óØObj : ùí∞ ùëñ
  ‚óØObj = ‚óØCtx

  ‚óØHom : ‚óØObj -> ‚óØObj -> ùí∞ _
  ‚óØHom Œì Œî = Œì ‚áõ Œî ‚à£ split all

  ----------------------------------------------------------
  -- Constructing the functors
  --
  -- 1) from local to global by using "Ôº†"
  --
  ---------------------
  -- The object map
  FÔº† : ‚ñ≤Obj p -> ‚óØObj
  FÔº† (Œì , P) = Œì
  -- FÔº† l Œµ = Œµ
  -- FÔº† l (Œì , A ¬© Œ¥) = FÔº† l Œì , A Ôº† l ¬© Œ¥


  --
  ---------------------
  -- The arrow map
  --
  map-FÔº† : ‚àÄ{A B : ‚ñ≤Obj p} -> ‚ñ≤Hom p A B -> ‚óØHom (FÔº† A) (FÔº† B)
  map-FÔº† f = {!f!}
  -- We have to...
  --
  -- FÔº†-Var : Œû ‚ä¢‚ñ≤-Var A -> FÔº† l Œû ‚ä¢‚óØ-Var A Ôº† l
  -- FÔº†-Var zero = zero
  -- FÔº†-Var (suc v) = suc (FÔº†-Var v)

  -- FÔº†-Term : Œû ‚ä¢‚ñ≤ A  -> FÔº† l Œû ‚ä¢‚óØ A Ôº† l
  -- FÔº†-Term = {!!}

  -- 2) from global to local by using ‚óª
  --
  ---------------------
  -- The object map
  F‚óª : ‚àÄ p -> ‚óØObj -> ‚ñ≤Obj p
  F‚óª p Œµ = Œµ , Œµ
  F‚óª p (Œì , X ¬© Œ¥) =
    let Œì' , Œì'P = F‚óª p Œì
    in (Œì' , ‚óª X Ôº† re p ¬© Œ¥) , step Œì'P


  ---------------------------------------------
  -- The natural transformations
  Œµ-Comp : ‚àÄ(Œì : ‚óØObj) -> ‚óØHom (FÔº† (F‚óª p Œì)) Œì
  Œµ-Comp Œµ = Œµ
  Œµ-Comp {p = p} (Œì , X ¬© Œ¥) = {!!} , e
    where
      e : ‚àÄ {Œì} -> Œì , ‚óª X Ôº† re p ¬© Œ¥ ‚ä¢‚óØ X ‚à£ split {{L}} all ¬© Œ¥
      e q q‚ààall A Ap with q ‚âü p
      ... | no x = {!recv ?!}
      ... | yes x = {!!}


{-





module _ where

  open import Data.Fin using (#_ ; zero ; suc ; Fin)
  open import Data.List using (_‚à∑_ ; [])
  open import Data.Vec using ([] ; _‚à∑_ ; _++_) renaming (Vec to StdVec)

  open import KamiTheory.Basics hiding (typed)
  open import KamiTheory.Order.Preorder.Instances

  -------------------
  -- The preorder of 3 processes with common knowledge is
  -- the standard preorder on `Fin 3 ‚Üí Bool`, which inherits
  -- the structure from `Bool` itself. We encode such functions
  -- as bool-vectors of length 3. Note that while we actually
  -- have to take the opposite preorder of that, we do so implicitly
  -- by defining our singleton lists to be inverted, i.e., everywhere
  -- true except at the required position.
  PP : Preorder _
  PP = ‚Ä≤ StdVec ùüö 3 ‚Ä≤

  -- Singletons are vectors with `true` everywhere except the required
  -- position
  singleton : Fin 3 -> ‚ü® PP ‚ü©
  singleton i = singletonVec true false i

  -- We postulate that the relation is merely a proposition.
  postulate instance
    _ : ‚àÄ{a b : ‚ü® PP ‚ü©} -> isProp (a ‚â§ b)

  -------------------
  -- Various shorter notations
  P : ùí∞ _
  P = ‚ü® PP ‚ü©

  -- We call the three processes `uu`, `vv` and `ww`
  uu vv ww : P
  uu = singleton (# 0)
  vv = singleton (# 1)
  ww = singleton (# 2)

  -- this is the common knowledge of both `uu` and `vv`
  uuvv : P
  uuvv = false ‚à∑ (false ‚à∑ (true ‚à∑ []))

  pattern UVP = false ‚à∑ false ‚à∑ true ‚à∑ []
  pattern UP = false ‚à∑ true ‚à∑ true ‚à∑ []
  pattern VP = true ‚à∑ false ‚à∑ true ‚à∑ []



  split-PP : ‚ü® PP ‚ü© ‚Üí List ‚ü® PP ‚ü©
  split-PP (x ‚à∑ y ‚à∑ z ‚à∑ []) =
        pure x uu <> pure y vv <> pure z ww
    where
      pure : Bool -> ‚ü® PP ‚ü© -> List ‚ü® PP ‚ü©
      pure false x = x ‚à∑ []
      pure true x = []

  postulate instance
    _ : hasFiniteMeets PP

  open IR {Loc = PP} {{it}} split
  ----------------------------------------------------------
  -- Examples
  --
  -- 1) sending and receiving a value
  ex1 : Œµ , BB Ôº† uu ¬© [] ‚ä¢‚óØ BB Ôº† vv ‚à£ (uu ‚à∑ vv ‚à∑ []) ¬© (com (BB Ôº† vv) uu ‚â´ [])
  ex1 = []
      , proj-Ôº† refl-‚â§ by recv (var zero {!!})
      , proj-Ôº†-‚â† {!!} by send ((box ([] , proj-Ôº† refl-‚â§ by var zero (proj-Ôº† refl-‚â§)))) tt


  -- 2) sending and receiving a value, continuing differently depending on it
  ex2 : Œµ , BB Ôº† uu ¬© [] , BB Ôº† vv ¬© []
        ‚ä¢‚óØ
        BB Ôº† uu ‚à£ (uu ‚à∑ vv ‚à∑ []) ¬© (com (BB Ôº† uuvv) uu ‚â´ ((com (BB Ôº† uu) vv ‚â´ []) ‚äπ []))
  ex2 = []
      , proj-Ôº†-‚â† {!!} by
        recv
        (rec-Either (var zero (proj-Ôº† {!!})) (send (box ([] , proj-Ôº† {!!} by var (suc zero) {!!})) tt) tt)

        -- (recv (proj-Ôº† (step ‚à∑ (refl-‚â§-ùüö ‚à∑ (refl-‚â§-ùüö ‚à∑ [])))))
      , proj-Ôº† {!!} by
        send ((box ([] , proj-Ôº† {!!} by var zero {!!}
                       , proj-Ôº† {!!} by var zero {!!})))
        (rec-Either (var zero (proj-Ôº† {!!}))
                    (recv (var zero {!!}))
                    (left tt))



-}


